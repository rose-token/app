// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @dev Minimal interface for Treasury price queries
 */
interface ITreasury {
    function getAssetPrice(bytes32 key) external view returns (uint256);
}

/**
 * @title MockLiFiDiamond
 * @dev Mock LiFi Diamond for testing. Simulates cross-chain/DEX aggregator swaps.
 *
 * In production, LiFi Diamond accepts complex calldata generated by LiFi SDK.
 * This mock accepts a simple ABI-encoded format for testing:
 *   - swapSimple(address fromToken, address toToken, uint256 amountIn, uint256 minAmountOut, address recipient)
 *   - Or via fallback with same encoding
 *
 * The Treasury's executeSwap() will call this contract with backend-generated calldata.
 * For tests, we generate the calldata using abi.encodeWithSelector or abi.encode.
 */
contract MockLiFiDiamond {
    using SafeERC20 for IERC20;

    // Exchange rates: tokenIn => tokenOut => rate (scaled by 1e18)
    // rate = how much tokenOut you get per 1e18 tokenIn (before decimal adjustment)
    mapping(address => mapping(address => uint256)) public exchangeRates;

    // Token decimals for conversion
    mapping(address => uint8) public tokenDecimals;

    // Treasury reference for dynamic pricing (optional, can be zero)
    address public treasury;

    // Token address => Asset key mapping (for Treasury.getAssetPrice())
    mapping(address => bytes32) public tokenAssetKeys;

    // Track swaps for test assertions
    struct SwapRecord {
        address fromToken;
        address toToken;
        uint256 amountIn;
        uint256 amountOut;
        address recipient;
        uint256 timestamp;
    }
    SwapRecord[] public swapHistory;

    // Events
    event SwapExecuted(
        address indexed fromToken,
        address indexed toToken,
        uint256 amountIn,
        uint256 amountOut,
        address indexed recipient
    );

    event ExchangeRateSet(
        address indexed fromToken,
        address indexed toToken,
        uint256 rate
    );

    constructor() {}

    /**
     * @dev Set exchange rate for a token pair
     * @param fromToken Source token
     * @param toToken Destination token
     * @param rate Rate scaled by 1e18 (e.g., 1e18 = 1:1 ratio before decimals)
     */
    function setExchangeRate(
        address fromToken,
        address toToken,
        uint256 rate
    ) external {
        exchangeRates[fromToken][toToken] = rate;
        emit ExchangeRateSet(fromToken, toToken, rate);
    }

    /**
     * @dev Set token decimals for proper conversion
     * @param token Token address
     * @param decimals Token decimals
     */
    function setTokenDecimals(address token, uint8 decimals) external {
        tokenDecimals[token] = decimals;
    }

    /**
     * @dev Set treasury address for dynamic pricing (optional)
     * @param _treasury Treasury contract address
     */
    function setTreasury(address _treasury) external {
        treasury = _treasury;
    }

    /**
     * @dev Set token to asset key mapping for Treasury price lookups
     * @param token Token address
     * @param key Asset key in Treasury (e.g., bytes32("ROSE"), bytes32("STABLE"))
     */
    function setTokenAssetKey(address token, bytes32 key) external {
        tokenAssetKeys[token] = key;
    }

    /**
     * @dev Simple swap function - can be called directly or via encoded calldata
     * @param fromToken Source token
     * @param toToken Destination token
     * @param amountIn Amount of source token to swap
     * @param minAmountOut Minimum amount of destination token expected
     * @param recipient Address to receive swapped tokens
     * @return amountOut Actual amount of destination token received
     */
    function swapSimple(
        address fromToken,
        address toToken,
        uint256 amountIn,
        uint256 minAmountOut,
        address recipient
    ) external returns (uint256 amountOut) {
        return _executeSwap(fromToken, toToken, amountIn, minAmountOut, recipient);
    }

    /**
     * @dev Fallback function to handle LiFi-style calldata
     * Expects ABI-encoded: (address fromToken, address toToken, uint256 amountIn, uint256 minAmountOut, address recipient)
     *
     * This allows Treasury to call: lifiDiamond.call(lifiData) where lifiData encodes the swap params
     */
    fallback(bytes calldata data) external payable returns (bytes memory) {
        // Decode swap parameters from calldata
        // Skip first 4 bytes if it's a function selector, otherwise decode raw
        bytes calldata params;
        if (data.length >= 4) {
            // Check if first 4 bytes match swapSimple selector
            bytes4 selector = bytes4(data[:4]);
            if (selector == this.swapSimple.selector) {
                params = data[4:];
            } else {
                // Assume raw encoded params (for flexibility in testing)
                params = data;
            }
        } else {
            params = data;
        }

        (
            address fromToken,
            address toToken,
            uint256 amountIn,
            uint256 minAmountOut,
            address recipient
        ) = abi.decode(params, (address, address, uint256, uint256, address));

        uint256 amountOut = _executeSwap(fromToken, toToken, amountIn, minAmountOut, recipient);

        // Return encoded amountOut (matches LiFi return pattern)
        return abi.encode(amountOut);
    }

    /**
     * @dev Internal swap execution
     */
    function _executeSwap(
        address fromToken,
        address toToken,
        uint256 amountIn,
        uint256 minAmountOut,
        address recipient
    ) internal returns (uint256 amountOut) {
        require(fromToken != address(0), "Invalid fromToken");
        require(toToken != address(0), "Invalid toToken");
        require(amountIn > 0, "Amount must be > 0");
        require(recipient != address(0), "Invalid recipient");

        // Calculate output amount BEFORE transferring (preserves price state for ROSE)
        // This is critical because ROSE price depends on Treasury's ROSE balance,
        // which affects circulatingSupply. Transferring first would change the price.
        amountOut = _calculateAmountOut(fromToken, toToken, amountIn);
        require(amountOut >= minAmountOut, "Slippage exceeded");

        // Now execute transfers
        IERC20(fromToken).safeTransferFrom(msg.sender, address(this), amountIn);
        IERC20(toToken).safeTransfer(recipient, amountOut);

        // Record swap for test assertions
        swapHistory.push(SwapRecord({
            fromToken: fromToken,
            toToken: toToken,
            amountIn: amountIn,
            amountOut: amountOut,
            recipient: recipient,
            timestamp: block.timestamp
        }));

        emit SwapExecuted(fromToken, toToken, amountIn, amountOut, recipient);

        return amountOut;
    }

    /**
     * @dev Calculate output amount based on exchange rate and decimals
     * Priority: 1) Treasury dynamic pricing, 2) Static exchange rates, 3) 1:1 fallback
     */
    function _calculateAmountOut(
        address fromToken,
        address toToken,
        uint256 amountIn
    ) internal view returns (uint256) {
        // Try dynamic pricing via Treasury first
        if (treasury != address(0)) {
            bytes32 fromKey = tokenAssetKeys[fromToken];
            bytes32 toKey = tokenAssetKeys[toToken];

            if (fromKey != bytes32(0) && toKey != bytes32(0)) {
                // Query Treasury for prices (8 decimals, Chainlink format)
                uint256 fromPrice = ITreasury(treasury).getAssetPrice(fromKey);
                uint256 toPrice = ITreasury(treasury).getAssetPrice(toKey);

                if (fromPrice > 0 && toPrice > 0) {
                    // Get decimals
                    uint8 decimalsIn = tokenDecimals[fromToken];
                    uint8 decimalsOut = tokenDecimals[toToken];
                    if (decimalsIn == 0) decimalsIn = 18;
                    if (decimalsOut == 0) decimalsOut = 18;

                    // Calculate: amountOut = amountIn * fromPrice / toPrice (adjusted for decimals)
                    // valueInUSD = amountIn * fromPrice / 10^decimalsIn (result in 8 decimals)
                    // amountOut = valueInUSD * 10^decimalsOut / toPrice
                    uint256 valueIn8Dec = (amountIn * fromPrice) / (10 ** decimalsIn);
                    return (valueIn8Dec * (10 ** decimalsOut)) / toPrice;
                }
            }
        }

        // Fallback to static exchange rates
        uint256 rate = exchangeRates[fromToken][toToken];

        if (rate == 0) {
            // Default: 1:1 rate adjusted for decimals
            uint8 decimalsIn = tokenDecimals[fromToken];
            uint8 decimalsOut = tokenDecimals[toToken];
            if (decimalsIn == 0) decimalsIn = 18;
            if (decimalsOut == 0) decimalsOut = 18;

            if (decimalsOut >= decimalsIn) {
                return amountIn * (10 ** (decimalsOut - decimalsIn));
            } else {
                return amountIn / (10 ** (decimalsIn - decimalsOut));
            }
        }

        // Apply rate (rate is scaled by 1e18)
        return (amountIn * rate) / 1e18;
    }

    /**
     * @dev Get swap history count for test assertions
     */
    function getSwapCount() external view returns (uint256) {
        return swapHistory.length;
    }

    /**
     * @dev Get specific swap record for test assertions
     */
    function getSwap(uint256 index) external view returns (
        address fromToken,
        address toToken,
        uint256 amountIn,
        uint256 amountOut,
        address recipient,
        uint256 timestamp
    ) {
        require(index < swapHistory.length, "Index out of bounds");
        SwapRecord memory record = swapHistory[index];
        return (
            record.fromToken,
            record.toToken,
            record.amountIn,
            record.amountOut,
            record.recipient,
            record.timestamp
        );
    }

    /**
     * @dev Get last swap record for test assertions
     */
    function getLastSwap() external view returns (
        address fromToken,
        address toToken,
        uint256 amountIn,
        uint256 amountOut,
        address recipient,
        uint256 timestamp
    ) {
        require(swapHistory.length > 0, "No swaps recorded");
        SwapRecord memory record = swapHistory[swapHistory.length - 1];
        return (
            record.fromToken,
            record.toToken,
            record.amountIn,
            record.amountOut,
            record.recipient,
            record.timestamp
        );
    }

    /**
     * @dev Clear swap history (for test isolation)
     */
    function clearSwapHistory() external {
        delete swapHistory;
    }

    /**
     * @dev Quote function - returns expected output without executing swap
     */
    function getQuote(
        address fromToken,
        address toToken,
        uint256 amountIn
    ) external view returns (uint256 amountOut) {
        return _calculateAmountOut(fromToken, toToken, amountIn);
    }

    /**
     * @dev Generate calldata for swapSimple (helper for tests)
     */
    function encodeSwapCalldata(
        address fromToken,
        address toToken,
        uint256 amountIn,
        uint256 minAmountOut,
        address recipient
    ) external pure returns (bytes memory) {
        return abi.encodeWithSelector(
            this.swapSimple.selector,
            fromToken,
            toToken,
            amountIn,
            minAmountOut,
            recipient
        );
    }

    // Allow receiving ETH for potential native token swaps
    receive() external payable {}
}
